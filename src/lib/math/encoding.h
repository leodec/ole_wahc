/*
    Implements general NTT for plaintext encoding
*/

#ifndef LBCRYPTO_MATH_ENCODING_H
#define LBCRYPTO_MATH_ENCODING_H

#include <array>
#include "dcrt.h"
#include "bit_twiddle.h"
#include "utils/test.h"

namespace lbcrypto {

    template <typename RingType>
    class EncodingContext_Base {
    public:
        using value_type = typename RingType::value_type;
        virtual poly<RingType> packed_encode(const poly<RingType>& element) const = 0;
        virtual poly<RingType> packed_decode(const value_type element[RingType::phim]) const = 0;
        virtual ~EncodingContext_Base() {};
    };

    template <typename RingType_in, typename RingType_in::value_type t>
    class EncodingContext : public EncodingContext_Base<RingType_in> {
    public:

        typedef RingType_in RingType;

        using value_type = typename RingType::value_type;
        using greater_value_type = typename RingType::greater_value_type;

        static constexpr ui32 logn = RingType::logn;
        static constexpr ui32 phim = (1 << logn);

        // using encoding_scalar_t = typename value_type;
        typedef value_type encoding_scalar_t;
        typedef poly<RingType> encoding_input_t;
        typedef poly<RingType> ptPoly;
        typedef poly<RingType> poly;

        static constexpr value_type modulus = t;

        alignas(32) value_type * rootsOfUnity = new value_type[2*phim];
        value_type * rootsOfUnityShoup = rootsOfUnity + phim;

        alignas(32) value_type * rootsOfUnityInverse = new value_type[2*phim];
        value_type * rootsOfUnityInverseShoup = rootsOfUnityInverse + phim;

        alignas(32) value_type * scaledInverses = new value_type[2*phim];
        value_type * scaledInversesShoup = scaledInverses + phim;

        alignas(32) ui32 * reverseMap = new ui32[phim];

        alignas(32) ui32 * to_ftt_perm = new ui32[phim];
        alignas(32) ui32 * from_ftt_perm = new ui32[phim];


        static constexpr inline value_type compute_shoup(const value_type in) {
            return ((greater_value_type)in << RingType::getModulusRepresentationBitSize()) / modulus;
        };

        constexpr inline void ftt_precompute(const value_type rootOfUnity, const value_type phim_inv=0) {
            //Precomputes twiddle factor omega and FTT parameter phi for Forward Transform
            value_type x(1);
            for (ui32 i = 0; i<phim; i++) {
                rootsOfUnity[i] = x;
                rootsOfUnityShoup[i] = compute_shoup(x);
                x = mod_mul_slow(x, rootOfUnity, modulus);
            }
            ASSERT_DEBUG(mod_exp(rootOfUnity, (value_type)(2*phim), modulus) == 1);

            //Precomputes twiddle factor omega and FTT parameter phi for Inverse Transform
            x = 1;
            value_type rootOfUnityInverse = mod_exp(rootOfUnity, (value_type)(2*phim-1), modulus);
            // if (rou_inv == 0) rootOfUnityInverse = mod_inv(rootOfUnity, modulus);
            // else rootOfUnityInverse = rou_inv;
            // value_type rootOfUnityInverse = mod_inv(rootOfUnity, modulus);
            ASSERT_DEBUG(mod_mul_slow(rootOfUnity, rootOfUnityInverse, modulus) == 1);
            for (ui32 i = 0; i<phim; i++) {
                rootsOfUnityInverse[i] = x;
                rootsOfUnityInverseShoup[i] = compute_shoup(x);
                x = mod_mul_slow(x, rootOfUnityInverse, modulus);
            }

            // value_type phim_inverse = mod_inv(phim, modulus);
            value_type phim_inverse;
            if (phim_inv == 0) phim_inverse = mod_inv(phim, modulus);
            else phim_inverse = phim_inv;
            ASSERT_DEBUG(mod_mul_slow(phim_inverse, phim, modulus) == 1);
            for (ui32 i = 0; i<phim; i++) {
                scaledInverses[i] = mod_mul_slow(phim_inverse, rootsOfUnityInverse[i], modulus);
                scaledInversesShoup[i] = compute_shoup(scaledInverses[i]);
            }

            for (ui32 i = 0; i < phim; i++) {
                reverseMap[i] = ReverseBits(i, logn);
                ASSERT_DEBUG(reverseMap[i] < phim);
            }
        };

        constexpr inline void permutation_precompute() {
            ui32 phim_by_2 = phim/2;
            ui32 mask = phim*2-1;

            // Create the permutations that interchange the automorphism and crt ordering
            // First we create the cyclic group generated by 5 and then adjoin the co-factor by multiplying by 3

            ui32 curr_index = 1;
            for (ui32 i = 0; i < phim_by_2; i++) {
                to_ftt_perm[(curr_index - 1) / 2] = i;
                from_ftt_perm[i] = (curr_index - 1) / 2;

                ui32 cofactor_index = (curr_index * mask) & mask;
                to_ftt_perm[(cofactor_index - 1) / 2] = i + phim_by_2;
                from_ftt_perm[i + phim_by_2] = (cofactor_index - 1) / 2;

                curr_index = (curr_index * 5) & mask;
            }
        };

        constexpr EncodingContext(const value_type rou=0, const value_type phim_inv=0) {
            CHECK_DEBUG;
            // static_assert(RingType::getModulus(encoding_input_t::modInd) >= t, "encoding modulus is too small");
            if (rou == 0)
                ftt_precompute(RootOfUnity(1<<(logn+1), modulus));
            else
                ftt_precompute(rou, phim_inv);
            permutation_precompute();
        };

        ~EncodingContext() {
            // std::cout << "In EncodingContext destructor\n";
            delete[] rootsOfUnity;
            delete[] rootsOfUnityInverse;
            delete[] scaledInverses;
            delete[] reverseMap;
            delete[] to_ftt_perm;
            delete[] from_ftt_perm;
        }


        //Number Theoretic Transform - ITERATIVE IMPLEMENTATION -  twiddle factor table precomputed
        // void ntt_fwd(value_type element[phim], const value_type rootOfUnityTable[phim], const value_type rootOfUnityShoupTable[phim]) const {
        void ntt_fwd(value_type element[phim], const value_type rootOfUnityTable[phim]) const {
            value_type * result = new value_type[phim];
            for (ui32 i = 0; i < phim; i++) result[i] = 0;

            //reverse coefficients (bit reversal)
            for (ui32 i = 0; i < phim; i++)
                result[i] = element[reverseMap[i]];

            value_type omegaFactor;
            value_type butterflyPlus;
            value_type butterflyMinus;

            for (ui32 logm = 1; logm <= logn; logm++) {
                for (ui32 j = 0; j<phim; j = j + (1 << logm)) {
                    for (ui32 i = 0; i < (ui32)(1 << (logm-1)); i++) {

                        ui32 x = (i << (1+logn-logm));

                        value_type omega = rootOfUnityTable[x];
                        // value_type omegaShoup = rootOfUnityShoupTable[x];

                        ui32 indexEven = j + i;
                        ui32 indexOdd = j + i + (1 << (logm-1));

                        if (result[indexOdd] != 0) {
                            if (result[indexOdd] == 1)
                                omegaFactor = omega;
                            else
                                // TODO: Shoup makes this slower... ??
                                // omegaFactor = mod_mul_shoup(result[indexOdd], omega, omegaShoup, modulus);
                                omegaFactor = mod_mul_slow(omega, result[indexOdd], modulus);

                            butterflyPlus = result[indexEven];
                            butterflyPlus += omegaFactor;
                            if (butterflyPlus >= modulus)
                                butterflyPlus -= modulus;

                            butterflyMinus = result[indexEven];
                            if (result[indexEven] < omegaFactor)
                                butterflyMinus += modulus;
                            butterflyMinus -= omegaFactor;

                            result[indexEven] = butterflyPlus;
                            result[indexOdd] = butterflyMinus;
                        } else {
                              result[indexOdd] = result[indexEven];
                        }
                    }
                }
            }
            std::copy(result, result+phim, element);
            delete[] result;
        };

        //main Forward CRT Transform - implements FTT - uses iterative NTT as a subroutine
        inline void ftt_fwd(value_type element[phim]) const {
            for (ui32 i = 0; i<phim; i++)
                element[i] = RingType::mod_mul_shoup(element[i], rootsOfUnity[i], rootsOfUnityShoup[i], modulus);
                // element[i] = mod_mul_slow(element[i], rootsOfUnity[i], modulus);

            // ntt_fwd(element, rootsOfUnity, rootsOfUnityShoup);
            ntt_fwd(element, rootsOfUnity);
        };

        inline void ftt_inv(value_type element[phim]) const {
            // ntt_fwd(element, rootsOfUnityInverse, rootsOfUnityInverseShoup);
            ntt_fwd(element, rootsOfUnityInverse);
            for (ui32 i=0; i<phim; i++)
                element[i] = RingType::mod_mul_shoup(element[i], scaledInverses[i], scaledInversesShoup[i], modulus);
                // element[i] = mod_mul_slow(element[i], scaledInverses[i], modulus);
        };

        ptPoly packed_encode(const encoding_input_t& element) const {
            // std::cout << "In packed_encode\n";
            // Permute to CRT Order
            ptPoly element_perm;
            for (ui32 i = 0; i < phim; i++)
                element_perm[i] = element[to_ftt_perm[i]];

            ftt_inv(element_perm);
            return element_perm;
        };

        // encoding_input_t packed_decode(const ptPoly& element) const {
        encoding_input_t packed_decode(const value_type element[phim]) const {
            value_type ftt_input[phim];
            std::copy(element, element+phim, ftt_input);
            DEBUG_FUNC(check_arr_eq(element, ftt_input, phim, "decode copy wrong!"));
            ftt_fwd(ftt_input);
            // Permute to automorphism Order
            encoding_input_t element_perm;
            for (ui32 i = 0; i < phim; i++)
                element_perm[i] = ftt_input[from_ftt_perm[i]];
            return element_perm;
        };

        //
        // Testing and debugging
        //

        static encoding_input_t generateRandomInput(const bool random = true, const value_type v = 0) {
            encoding_input_t result;
            if (random) result.random(modulus);
            else result.repeat_const(v);
            return result;
        };

        static bool check_encoding_inputs_eq(const encoding_input_t& in1, const encoding_input_t& in2, const int verbose = 0) {
            for (ui32 i = 0; i < phim; i++) {
                if (in1[i] != in2[i]) {
                    if (verbose > 0) {
                        std::cout << "Mimatch at index " << i << std::endl;
                        std::cout << in1[i] << " != " << in2[i] << std::endl;
                        if (verbose > 1) {
                            std::cout << "Full inputs\n";
                            std::cout << arr_to_string(in1.vals, phim) << std::endl;
                            std::cout << arr_to_string(in2.vals, phim) << std::endl;
                        }
                    }
                    return false;
                }
            }
            return true;
        };

        static encoding_input_t enc_input_sum(const encoding_input_t& in1, const encoding_input_t& in2) {
            encoding_input_t result;
            for (ui32 j = 0; j < phim; j++)
                result[j] = (in1[j] + in2[j]) % t;
            return result;
        };

        static encoding_input_t enc_input_diff(const encoding_input_t& in1, const encoding_input_t& in2) {
            encoding_input_t result;
            for (ui32 j = 0; j < phim; j++)
                result[j] = (in1[j] + t - in2[j]) % t;
            return result;
        };

        static encoding_input_t enc_input_prod(const encoding_input_t& in1, const encoding_input_t& in2) {
            encoding_input_t result;
            for (ui32 j = 0; j < phim; j++)
                result[j] = mod_mul_slow(in1[j], in2[j], t);
            return result;
        };
    };

    template <typename RingType, ui32 numModuli_in, typename RingType::value_type t1, typename RingType::value_type ... tRest>
    struct DCRTEncodingContext {

        using input_value_type = typename RingType::value_type;
        typedef ui64 value_type;
        typedef ui128 greater_value_type;

        static constexpr ui32 logn = RingType::logn;
        static constexpr ui32 phim = 1<<logn;
        static constexpr ui32 numModuli = numModuli_in;

        typedef poly<RingType> ptPoly;
        typedef poly<RingType> inputPoly;
        typedef Array2d<input_value_type, numModuli, phim> encoding_input_t;

        template <class none = void>  // Base case for template product
        static constexpr value_type templateProd() { return 1; };

        template<input_value_type i, input_value_type ... j>
        static constexpr value_type templateProd() {
            return (value_type)i * templateProd<j...>();
        };

        template <class none = void>  // Base case for list initiation
        static void push_next(std::array<input_value_type, numModuli>& vec, ui32 ind) {
            // static_assert(ind == numModuli, "mod vector is wrong length!");
            return;
        };

        template <input_value_type currMod, input_value_type ... restMod>
        static void push_next(std::array<input_value_type, numModuli>& vec, ui32 ind = 0) {
            vec[ind] = currMod;
            push_next<restMod...>(vec, ++ind);
        };

        static std::array<input_value_type, numModuli> initModList() {
            std::array<input_value_type, numModuli> result;
            push_next<t1, tRest...>(result);
            return result;
        };

        static constexpr value_type modulus = templateProd<t1, tRest...>();
        static const std::array<input_value_type, numModuli_in> moduli;

        // NOTE: tried shoup, didn't work...
        value_type ti_star[numModuli] __attribute__((aligned(32)));
        value_type ti_tilde[numModuli] __attribute__((aligned(32)));
        // For binary inputs
        value_type ti_binary_coeffs[numModuli] __attribute__((aligned(32)));

        value_type rootOfUnity;
        value_type phimInverse;

        typedef EncodingContext<RingType, modulus> InnerEncodingContextType;
        EncodingContext_Base<RingType> * encoding_context;

        inline void prepCRTCoeffs() {
            for (ui32 i = 0; i < numModuli; i++) {
                ti_star[i] = modulus/moduli[i];
                ti_tilde[i] = mod_inv(ti_star[i], moduli[i]);
                ASSERT_DEBUG(mod_mul_slow(ti_star[i], ti_tilde[i], moduli[i]) == 1);
                ti_binary_coeffs[i] = mod_mul_slow(ti_star[i], ti_tilde[i], modulus);
            }
        };

        inline void compute_NTT_Params() {
            rootOfUnity = 0;
            for (ui32 i = 0; i < numModuli; i++) {
                value_type rou = RootOfUnity(1<<(logn+1), moduli[i]);
                rootOfUnity += mod_mul_slow(
                    mod_mul_slow(rou, ti_tilde[i], moduli[i]), ti_star[i], modulus
                );
                rootOfUnity = mod_slow(rootOfUnity, modulus);
            }
            ASSERT_DEBUG(mod_exp(rootOfUnity, (value_type)(2*phim), modulus) == 1);

            phimInverse = 0;
            for (ui32 i = 0; i < numModuli; i++) {
                value_type phimInv = mod_inv(phim, moduli[i]);
                phimInverse += mod_mul_slow(
                    mod_mul_slow(phimInv, ti_tilde[i], moduli[i]), ti_star[i], modulus
                );
                phimInverse = mod_slow(phimInverse, modulus);
            }
            ASSERT_DEBUG(mod_mul_slow(phim, phimInverse, modulus) == 1);
        };

        bool checkRep() {
            value_type testModulus = 1;
            for (ui32 i = 0; i < numModuli; i++)
                testModulus *= moduli[i];
            return (modulus == testModulus);
        };

        DCRTEncodingContext() {
            // moduli = initModList();
            static_assert(
                std::is_same<input_value_type, value_type>::value, 
                "Currently not supporting input_value_type != value_type"
            );
            ASSERT_DEBUG(checkRep());
            prepCRTCoeffs();
            compute_NTT_Params();
            encoding_context = new InnerEncodingContextType(rootOfUnity, phimInverse);

            static_assert(
                std::is_same<typename InnerEncodingContextType::poly, ptPoly>::value, 
                "Inner encoding output and our output mismatch!"
            );
        };

        ~DCRTEncodingContext() {
            delete encoding_context;
        };

        ptPoly packed_encode(const encoding_input_t& element) const {
            // recombine elements, then encode
            ptPoly recombined;
            for (ui32 i = 0; i < phim; i++) {
                recombined[i] = 0;
                for (ui32 modInd = 0; modInd < numModuli; modInd++) {
                    recombined[i] += mod_mul_slow(
                        mod_mul_slow(element[modInd][i], ti_tilde[modInd], moduli[modInd]),
                        ti_star[modInd], modulus
                    );
                    recombined[i] = mod_slow(recombined[i], modulus);
                }
            }

            return encoding_context->packed_encode(recombined);
        };

        encoding_input_t packed_decode(const ptPoly& element) const {
            // decode elements, then recombine
            ptPoly toDecompose = encoding_context->packed_decode(element);

            encoding_input_t result;
            for (ui32 i = 0; i < numModuli; i++) {
                for (ui32 j = 0; j < phim; j++) {
                    result[i][j] = 0;
                    result[i][j] = toDecompose[j] % moduli[i];
                }
            }

            return result;
        };

        //
        // Testing and Debugging
        //

        static encoding_input_t generateRandomInput(const bool random = true, const input_value_type v = 0) {
            encoding_input_t result;

            if (random)
                for (ui32 modInd = 0; modInd < numModuli; modInd++) {
                    inputPoly limb; limb.random(moduli[modInd]);
                    for (ui32 i = 0; i < phim; i++) result[modInd][i] = limb[i];
                }
            else
                for (ui32 modInd = 0; modInd < numModuli; modInd++) {
                    inputPoly limb; limb.repeat_const(v);
                    for (ui32 i = 0; i < phim; i++) result[modInd][i] = limb[i];
                }

            return result;
        };

        static bool check_encoding_inputs_eq(const encoding_input_t& in1, const encoding_input_t& in2, const int verbose = 0) {
            for (ui32 modInd = 0; modInd < numModuli; modInd++) {
                for (ui32 i = 0; i < phim; i++) {
                    if (in1[modInd][i] != in2[modInd][i]) {
                        if (verbose > 0) {
                            std::cout << "Mimatch at index " << modInd << ", " << i << std::endl;
                            std::cout << in1[modInd][i] << " != " << in2[modInd][i] << std::endl;
                            if (verbose > 1 && verbose < 3) {
                                std::cout << "Full limbs\n";
                                std::cout << arr_to_string(in1[modInd], phim) << std::endl;
                                std::cout << arr_to_string(in2[modInd], phim) << std::endl;
                            } else if (verbose > 2) {
                                std::cout << "Full input\n";
                                for (ui32 errInd = 0; errInd < numModuli; errInd++) {
                                    std::cout << arr_to_string(in1[errInd], phim) << std::endl;
                                    std::cout << arr_to_string(in2[errInd], phim) << std::endl;
                                }
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        };

        static encoding_input_t enc_input_sum(const encoding_input_t& in1, const encoding_input_t& in2) {
            encoding_input_t result;
            for (ui32 i = 0; i < numModuli; i++)
                for (ui32 j = 0; j < phim; j++)
                    result[i][j] = (in1[i][j] + in2[i][j]) % moduli[i];
            return result;
        };

        static encoding_input_t enc_input_diff(const encoding_input_t& in1, const encoding_input_t& in2) {
            encoding_input_t result;
            for (ui32 i = 0; i < numModuli; i++)
                for (ui32 j = 0; j < phim; j++)
                    result[i][j] = (in1[i][j] + moduli[i] - in2[i][j]) % moduli[i];
            return result;
        };

        static encoding_input_t enc_input_prod(const encoding_input_t& in1, const encoding_input_t& in2) {
            encoding_input_t result;
            for (ui32 i = 0; i < numModuli; i++)
                for (ui32 j = 0; j < phim; j++)
                    result[i][j] = mod_mul_slow(in1[i][j], in2[i][j], moduli[i]);
            return result;
        };

    };

    template <typename RingType, ui32 numModuli_in, typename RingType::value_type t1, typename RingType::value_type ... tRest>
    const std::array<typename RingType::value_type, numModuli_in> DCRTEncodingContext<RingType, numModuli_in, t1, tRest...>::moduli = DCRTEncodingContext<RingType, numModuli_in, t1, tRest...>::initModList();


    //
    // Big Encoding Context for large moduli
    //

    template <
        typename input_value_type,
        typename RingType, ui32 numModuli_in, 
        typename RingType::value_type t1, typename RingType::value_type ... tRest>
    struct BigEncodingContext {

        using value_type = typename RingType::value_type;
        using greater_value_type = typename RingType::greater_value_type;

        static constexpr ui32 logn = RingType::logn;
        static constexpr ui32 phim = 1<<logn;
        static constexpr ui32 numModuli = numModuli_in;

        typedef poly<RingType> ptPoly;
        typedef Array<input_value_type, phim> encoding_input_t;
        
        template <class none = void>  // Base case for template product
        static constexpr input_value_type templateProd() { return 1; };

        template<input_value_type i, input_value_type ... j>
        static constexpr input_value_type templateProd() {
            return (input_value_type)i * templateProd<j...>();
        };

        template <class none = void>  // Base case for list initiation
        static void push_next(std::array<value_type, numModuli>& vec, ui32 ind) {
            // static_assert(ind == numModuli, "mod vector is wrong length!");
            return;
        };

        template <value_type currMod, value_type ... restMod>
        static void push_next(std::array<value_type, numModuli>& vec, ui32 ind = 0) {
            vec[ind] = currMod;
            push_next<restMod...>(vec, ++ind);
        };

        static std::array<value_type, numModuli> initModList() {
            std::array<value_type, numModuli> result;
            push_next<t1, tRest...>(result);
            return result;
        };

        static constexpr input_value_type modulus = templateProd<t1, tRest...>();
        static const std::array<value_type, numModuli_in> moduli;

        // NOTE: tried shoup, didn't work...
        input_value_type ti_star[numModuli] __attribute__((aligned(32)));
        value_type ti_tilde[2*numModuli] __attribute__((aligned(32)));
        value_type * ti_tilde_shoup = ti_tilde + numModuli;

        // EncodingContext_Base<RingType> * encoding_contexts[numModuli];

        inline void prepCRTCoeffs() {
            for (ui32 i = 0; i < numModuli; i++) {
                ti_star[i] = modulus/moduli[i];
                ti_tilde[i] = mod_inv(ti_star[i], moduli[i]);
                ASSERT_DEBUG(mod_mul_slow(ti_star[i], ti_tilde[i], moduli[i]) == 1);
                ti_tilde_shoup[i] = RingType::compute_shoup(ti_tilde[i], moduli[i]);
            }
        };

        // template <class none = void>
        // void compute_NTT_Params(ui32 ind) { return; };

        // template <value_type currMod, value_type ... nextMods> 
        // void compute_NTT_Params(ui32 ind = 0) {
        //     encoding_contexts[ind] = new EncodingContext<RingType, currMod>();
        //     compute_NTT_Params<nextMods...>(++ind);
        // };

        BigEncodingContext() {
            // static_assert(
            //     std::is_same<input_value_type, value_type>::value, 
            //     "Currently not supporting input_value_type != value_type"
            // );
            prepCRTCoeffs();
            // compute_NTT_Params<t1, tRest...>();
        };

        // ~BigEncodingContext() {
            // for (ui32 modInd = 0; modInd < numModuli; modInd++)
                // delete encoding_contexts[modInd];
        // };

        vector<ptPoly> packed_encode(const encoding_input_t& element) const {
            // decompose, then encode

            vector<ptPoly> result;  // (numModuli);
            result.reserve(numModuli);
            // PARALLEL_FOR
            for (ui32 i = 0; i < numModuli; i++) {
                ptPoly toEncode;
                for (ui32 j = 0; j < phim; j++) {
                    toEncode[j] = 0;
                    toEncode[j] = element[j] % (input_value_type)moduli[i];
                }
                // result.push_back(encoding_contexts[i]->packed_encode(toEncode));
                result.push_back(toEncode);
                // result[i] = toEncode;
            }

            return result;
            
        };

        encoding_input_t packed_decode(const vector<ptPoly>& element) const {
            // recombine elements, then encode

            // vector<ptPoly> toRecomb; toRecomb.reserve(numModuli);
            // for (ui32 modInd = 0; modInd < numModuli; modInd++) 
                // toRecomb.push_back(encoding_contexts[modInd]->packed_decode(element[modInd]));

            encoding_input_t recombined;
            for (ui32 i = 0; i < phim; i++) {
                recombined[i] = 0;
                for (ui32 modInd = 0; modInd < numModuli; modInd++) {
                    recombined[i] += mod_mul_slow(
                        // mod_mul_slow(element[modInd][i], ti_tilde[modInd], moduli[modInd]),
                        RingType::mod_mul_shoup(element[modInd][i], ti_tilde[modInd], ti_tilde_shoup[modInd], moduli[modInd]),
                        ti_star[modInd], modulus
                    );
                }
                recombined[i] = mod_slow(recombined[i], modulus);
            }

            return recombined;
        };

        //
        // Testing and Debugging
        //

        static encoding_input_t generateRandomInput(const bool random = true, const input_value_type v = 0) {
            encoding_input_t result;
            for (ui32 j = 0; j < phim; j++) {
                if (random) result[j] = rand() % modulus;
                else result[j] = v;
            }
            return result;
        };

        static bool check_encoding_inputs_eq(const encoding_input_t& in1, const encoding_input_t& in2, const int verbose = 0) {
            for (ui32 i = 0; i < phim; i++) {
                if (in1[i] != in2[i]) {
                    if (verbose > 0) {
                        std::cout << "Mimatch at index " << i << std::endl;
                        std::cout << to_string(in1[i]) << " != " << to_string(in2[i]) << std::endl;
                        if (verbose > 1) {
                            std::cout << "Full inputs\n";
                            std::cout << arr_to_string(in1.vals, phim) << std::endl;
                            std::cout << arr_to_string(in2.vals, phim) << std::endl;
                        }
                    }
                    return false;
                }
            }
            return true;
        };

        static encoding_input_t enc_input_sum(const encoding_input_t& in1, const encoding_input_t& in2) {
            encoding_input_t result;
            for (ui32 j = 0; j < phim; j++)
                result[j] = (in1[j] + in2[j]) % modulus;
            return result;
        };

        static encoding_input_t enc_input_diff(const encoding_input_t& in1, const encoding_input_t& in2) {
            encoding_input_t result;
            for (ui32 j = 0; j < phim; j++)
                result[j] = (in1[j] + modulus - in2[j]) % modulus;
            return result;
        };

        static encoding_input_t enc_input_prod(const encoding_input_t& in1, const encoding_input_t& in2) {
            encoding_input_t result;
            for (ui32 j = 0; j < phim; j++)
                result[j] = mod_mul_slow(in1[j], in2[j], modulus);
            return result;
        };

    };

    template <
        typename input_value_type,
        typename RingType, 
        ui32 numModuli_in, 
        typename RingType::value_type t1, typename RingType::value_type ... tRest
    >
    const std::array<typename BigEncodingContext<input_value_type, RingType, numModuli_in, t1, tRest...>::value_type, numModuli_in> 
    BigEncodingContext<input_value_type, RingType, numModuli_in, t1, tRest...>::moduli =
    BigEncodingContext<input_value_type, RingType, numModuli_in, t1, tRest...>::initModList();


    //
    // Poly (null) encoding context
    //

    template <typename RingType_in, typename RingType_in::value_type t>
    class NullEncodingContext : public EncodingContext_Base<RingType_in> {
    public:

        typedef RingType_in RingType;

        using value_type = typename RingType::value_type;
        using greater_value_type = typename RingType::greater_value_type;

        static constexpr ui32 logn = RingType::logn;
        static constexpr ui32 phim = (1 << logn);

        // using encoding_scalar_t = typename value_type;
        typedef value_type encoding_scalar_t;
        typedef poly<RingType> encoding_input_t;
        typedef poly<RingType> ptPoly;
        typedef poly<RingType> poly;

        static constexpr value_type modulus = t;

        constexpr NullEncodingContext() { CHECK_DEBUG; };

        ~NullEncodingContext() {}

        ptPoly packed_encode(const encoding_input_t& element) const {
            return encoding_input_t(element);
        };

        ptPoly packed_encode(const encoding_scalar_t& element) const {
            encoding_input_t result;
            result[0] = element;
            return result;
        };

        // encoding_input_t packed_decode(const ptPoly& element) const {
        encoding_input_t packed_decode(const value_type element[phim]) const {
            return encoding_input_t(element);
        };

        //
        // Testing and debugging
        //

        static encoding_input_t generateRandomInput(const bool random = true, const value_type v = 0) {
            encoding_input_t result;
            if (random) result.random(modulus);
            else result.repeat_const(v);
            return result;
        };

        static encoding_scalar_t generateRandomScalar() {
            return (encoding_scalar_t)(get_random_real()*(double)modulus);
        };

        static bool check_encoding_inputs_eq(const encoding_input_t& in1, const encoding_input_t& in2, const int verbose = 0) {
            for (ui32 i = 0; i < phim; i++) {
                if (in1[i] != in2[i]) {
                    if (verbose > 0) {
                        std::cout << "Mimatch at index " << i << std::endl;
                        std::cout << in1[i] << " != " << in2[i] << std::endl;
                        if (verbose > 1) {
                            std::cout << "Full inputs\n";
                            std::cout << arr_to_string(in1.vals, phim) << std::endl;
                            std::cout << arr_to_string(in2.vals, phim) << std::endl;
                        }
                    }
                    return false;
                }
            }
            return true;
        };

        static encoding_input_t enc_input_sum(const encoding_input_t& in1, const encoding_input_t& in2) {
            encoding_input_t result;
            for (ui32 j = 0; j < phim; j++)
                result[j] = (in1[j] + in2[j]) % t;
            return result;
        };

        static encoding_input_t enc_input_diff(const encoding_input_t& in1, const encoding_input_t& in2) {
            encoding_input_t result;
            for (ui32 j = 0; j < phim; j++)
                result[j] = (in1[j] + t - in2[j]) % t;
            return result;
        };

        static encoding_input_t enc_input_prod(const encoding_input_t& in1, const encoding_scalar_t& in2) {
            encoding_input_t result;
            for (ui32 j = 0; j < phim; j++)
                result[j] = mod_mul_slow(in1[j], in2, modulus);
            return result;
        };

        static encoding_input_t enc_input_prod(const encoding_input_t& in1, const encoding_input_t& in2) {
            encoding_input_t result;
            for (ui32 j = 0; j < phim; j++)
                result[j] = mod_mul_slow(in1[j], in2[j], modulus);
            return result;
        };
    };

}  // namespace lbcrypto ends


#endif
